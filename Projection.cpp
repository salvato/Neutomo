#include "StdAfx.h"
#include "float.h"
#include "math.h"
#include "Point2f.h"
#include "Projection.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#endif


CProjection::CProjection(void) 
  : FLOAT_UNDEFINED(-FLT_MAX)
  , INT_UNDEFINED(INT_MIN)
  , sErrorString(_T("No Error"))
  , pData(NULL)
  , n_rows(0)
  , n_columns(0)
  , f_BeamIntensity(FLOAT_UNDEFINED)
  , f_TimeOfFlight(FLOAT_UNDEFINED)
  , f_angle(FLOAT_UNDEFINED)
  , f_PosX(FLOAT_UNDEFINED)
  , f_PosY(FLOAT_UNDEFINED)
  , f_PosZ(FLOAT_UNDEFINED)
  , i_SliceNum(INT_UNDEFINED)
{
}


CProjection::CProjection(int nColumns, int nRows)
  : FLOAT_UNDEFINED(-FLT_MAX)
  , INT_UNDEFINED(INT_MIN)
  , sErrorString(_T("No Error"))
  , pData(NULL)
  , n_rows(nRows)
  , n_columns(nColumns)
  , f_BeamIntensity(FLOAT_UNDEFINED)
  , f_TimeOfFlight(FLOAT_UNDEFINED)
  , f_angle(FLOAT_UNDEFINED)
  , f_PosX(FLOAT_UNDEFINED)
  , f_PosY(FLOAT_UNDEFINED)
  , f_PosZ(FLOAT_UNDEFINED)
  , i_SliceNum(INT_UNDEFINED)
{
  pData = new float[n_rows*n_columns];
}


CProjection::~CProjection(void) {
  if(pData != NULL) delete[] pData;
  pData = NULL;
}


bool
CProjection::Normalize(float fMin, float fMax) {
  if(!IsInitialized()) 
    return false;
  float myMin, myMax;
  GetMinMax(&myMin, &myMax);
  for(int i=0; i<n_rows*n_columns; i++)
    pData[i] = (fMax-fMin)*((pData[i]-myMin)/(myMax-myMin) + fMin);
  return pData != NULL;
}


bool
CProjection::IsInitialized(void) {
  return pData != NULL;
}


bool
CProjection::InitFromData(float* pDatain, int nRows, int nColumns) {
  if(nRows < 1 || nColumns < 1) {
    sErrorString.Format(_T("Illegal Input Values"));
    return false;
  }
  n_rows = nRows;
  n_columns = nColumns;
  try {
    pData = new float[n_rows*n_columns];
  } catch(...) {
    sErrorString.Format(_T("Not Enough Memory to Initialize Projection"));
    return false;
  }
  int err;
  try {
    err = memcpy_s(pData, sizeof(*pData)*n_rows*n_columns, pDatain, sizeof(*pDatain)*n_rows*n_columns );
  } catch(...) {
    sErrorString.Format(_T("Error Copying Data\nImpossible to Initialize Projection"));
    delete[] pData;
    pData = NULL;
    return false;
  }
  if(err) {
    sErrorString.Format(_T("Error Copying Data\nImpossible to Initialize Projection"));
    delete[] pData;
    pData = NULL;
    return false;
  }
  sErrorString = _T("No error");
  return true;
}


bool
CProjection::Crop(int xStart, int xEnd, int yStart, int yEnd) {
  if(!IsInitialized()) {
    sErrorString.Format(_T("Error: Not Initialized"));
    return false;
  }
  if((xStart < 0) || (xStart > n_columns-1) || (xEnd < 1) || (xEnd > n_columns) ||
     (yStart < 0) || (yStart > n_rows-1)    || (yEnd < 1) || (yEnd > n_rows)    ||
     (xStart >= xEnd) || (yStart >= yEnd)) {
    sErrorString.Format(_T("Illegal Crop Region"));
    return false;
  }

  int xSize = xEnd-xStart;
  int ySize = yEnd-yStart;
  float* pTemp = new float[xSize*ySize];
  int yOffi, yOffo;
  for(int y=0; y<ySize; y++) {
    yOffi = (y+yStart)*n_columns+xStart;
    yOffo = y * xSize;
    for(int x=0; x<xSize; x++) {
      *(pTemp+yOffo+x) = *(pData+yOffi+x);
    }
  }
  n_columns = xSize;
  n_rows = ySize;

  delete[] pData;
  pData = pTemp;

  sErrorString = _T("No error");
  return true;
}


// A Median Filter
bool
CProjection::Median(int Ksize) {
  if(!IsInitialized()) {
    sErrorString.Format(_T("Error: Not Initialized"));
    return false;
  }
	int k2 = Ksize/2;
	int kmax= Ksize-k2;
	int i, j, k;
  int kk = Ksize*Ksize;
	float* kernel = new float[kk*sizeof(*pData)];
  float* tmp = new float[n_columns*n_rows*sizeof(*pData)];
  memcpy(tmp, pData, n_columns*n_rows*sizeof(*pData));

	int xmin, xmax, ymin, ymax;
	xmin = ymin = 0;
  xmax = n_columns; ymax = n_rows;
  float mean, fVal;

	for(int y=ymin; y<ymax; y++) {
		for(int x=xmin; x<xmax; x++) {
      mean = 0.0;
      for(j=-k2, i=0;j<kmax;j++) {
        for(k=-k2; k<kmax; k++) {
          if((x+j>-1 && y+k>-1) &&(x+j<n_columns && y+k<n_rows)) {
						fVal = *(pData+x+j+(y+k)*n_columns);
            mean += fVal;
						kernel[i++]=fVal;
          }
        } // for(j=-k2, i=0;j<kmax;j++) {for(k=-k2; k<kmax; k++)
      } // for(long x=xmin; x<xmax; x++) {for(j=-k2, i=0;j<kmax;j++)
      mean /= float(kk);
      if(fabs(*(tmp+x+y*n_columns)-mean) > f_MedianThreshold*mean) {
			  bSort(kernel, i);
			  *(tmp+x+y*n_columns) = kernel[i/2];
      }
		} // for(long y=ymin; y<ymax; y++) {for(long x=xmin; x<xmax; x++)
	} // for(long y=ymin; y<ymax; y++)

  delete[] kernel;
  memcpy(pData, tmp, n_columns*n_rows*sizeof(*pData));
  delete[] tmp;
  sErrorString = _T("No error");
	return true;
}


////////////////////////////////////////////////////////////////////////////////
/**
 * A Gaussian blur effect is typically generated by convolving an image with a 
 * kernel of Gaussian values. 
 * In practice, it is best to take advantage of the Gaussian blur’s separable 
 * property by dividing the process into two passes. 
 * In the first pass, a one-dimensional kernel is used to blur the image in only 
 * the horizontal or vertical direction. 
 * In the second pass, another one-dimensional kernel is used to blur in the 
 * remaining direction. 
 * The resulting effect is the same as convolving with a two-dimensional kernel 
 * in a single pass, but requires fewer calculations.
 * \author [nipper]; changes [DP]; adapted [GS]
 */
bool 
CProjection::GaussianBlur(float radius /* = 1.0f */, CProjection* iDst /* = NULL */) {
  if(!IsInitialized()) {
   sErrorString.Format(_T("Error: Not Initialized"));
   return false;
  }

	CProjection tmp(n_columns, n_rows);
	if(!tmp.IsInitialized()) {
    sErrorString.Format(_T("Error: temporary projection not initialized"));
		return false;
	}

	// generate convolution matrix and make sure it's smaller than each dimension
	float *cmatrix = NULL;
	int cmatrix_length = gen_convolve_matrix(radius, &cmatrix);

	// blur the rows
  for(int row=0; row<n_rows; row++) {
		blur_line(cmatrix, cmatrix_length, pData+n_columns*row, tmp.pData+n_columns*row, n_columns);
	}

  // blur the columns
  for(int column=0; column<n_columns; column++) {
		blur_column(cmatrix, cmatrix_length, tmp.pData+column, pData+column, n_rows, n_columns);
	}

	if(iDst) return iDst->Copy(*this);
	return true;
}


////////////////////////////////////////////////////////////////////////////////
//
// generates a 1-D convolution matrix to be used for each pass of 
// a two-pass gaussian blur.  Returns the length of the matrix.
// \author [nipper]
//
int 
CProjection::gen_convolve_matrix (float radius, float **cmatrix_p) {
	int matrix_length;
	int matrix_midpoint;
	float* cmatrix;
	int i,j;
	float std_dev;
	float sum;
	
	// we want to generate a matrix that goes out a certain radius
	// from the center, so we have to go out ceil(rad-0.5) pixels,
	// inlcuding the center pixel.  Of course, that's only in one direction,
	// so we have to go the same amount in the other direction, but not count
	// the center pixel again.  So we double the previous result and subtract
	// one.
	// The radius parameter that is passed to this function is used as
	// the standard deviation, and the radius of effect is the
	// standard deviation * 2.  It's a little confusing.
	// <DP> modified scaling, so that matrix_lenght = 1+2*radius parameter
	//
	radius = (float)fabs(0.5*radius) + 0.25f;
	
	std_dev = radius;
	radius = std_dev * 2;
	
	// go out 'radius' in each direction
	matrix_length = int (2 * ceil(radius-0.5) + 1);
	if (matrix_length <= 0) matrix_length = 1;
	matrix_midpoint = matrix_length/2 + 1;
	*cmatrix_p = new float[matrix_length];
	cmatrix = *cmatrix_p;
	
	//  Now we fill the matrix by doing a numeric integration approximation
	// from -2*std_dev to 2*std_dev, sampling 50 points per pixel.
	// We do the bottom half, mirror it to the top half, then compute the
	// center point.  Otherwise asymmetric quantization errors will occur.
	//  The formula to integrate is e^-(x^2/2s^2).
	//
	
	// first we do the top (right) half of matrix
	for(i = matrix_length/2 + 1; i < matrix_length; i++) {
		float base_x = i - (float)floor((float)(matrix_length/2)) - 0.5f;
		sum = 0;
		for(j = 1; j <= 50; j++) {
			if( base_x+0.02*j <= radius ) 
				sum += (float)exp (-(base_x+0.02*j)*(base_x+0.02*j) / 
				(2*std_dev*std_dev));
		}
		cmatrix[i] = sum/50.0f;
  }
	
	// mirror the thing to the bottom half
	for(i=0; i<=matrix_length/2; i++) {
		cmatrix[i] = cmatrix[matrix_length-1-i];
	}
	
	// find center val -- calculate an odd number of quanta to make it symmetric,
	// even if the center point is weighted slightly higher than others.
	sum = 0;
	for(j=0; j<=50; j++) {
		sum += (float)exp (-(0.5+0.02*j)*(0.5+0.02*j) /
			(2*std_dev*std_dev));
  }
	cmatrix[matrix_length/2] = sum/51;
	
	// normalize the distribution by scaling the total sum to one
	sum=0;
	for(i=0; i<matrix_length; i++) sum += cmatrix[i];
	for(i=0; i<matrix_length; i++) cmatrix[i] = cmatrix[i] / sum;
	
	return matrix_length;
}


////////////////////////////////////////////////////////////////////////////////
//
// \author [nipper], adapted [GS]
//
void
CProjection::blur_line(float *cmatrix, int cmatrix_length, float* src_row, float* dest_row, int nColumns) {
	float scale, sum;
  int cmatrix_middle = cmatrix_length/2;
	
	if(cmatrix_length > nColumns) {
		for(int column=0; column<nColumns; column++) {
			scale = 0;
			// find the scale factor
			for(int j=0; j<nColumns; j++) {
				// if the index is in bounds, add it to the scale counter
				if((j + cmatrix_middle - column >= 0) &&
					 (j + cmatrix_middle - column < cmatrix_length))
					scale += cmatrix[j + cmatrix_middle - column];
			}
			sum = 0;
			for(int j=0; j<nColumns; j++) {
				if((j >= column - cmatrix_middle) &&
					 (j <= column + cmatrix_middle))
					sum += src_row[j] * cmatrix[j];
			}
			dest_row[column] = float(sum / scale);
		}
  } else {
		// for the edge condition, we only use available info and scale to one
		for(int column=0; column<cmatrix_middle; column++) {
			// find scale factor
			scale=0;
			for(int j=cmatrix_middle-column; j<cmatrix_length; j++)
				scale += cmatrix[j];
	    sum = 0;
			for(int j=cmatrix_middle-column; j<cmatrix_length; j++) {
				sum += src_row[column + j-cmatrix_middle] * cmatrix[j];
			}
			dest_row[column] = float(sum / scale);
		}
		// go through each pixel
		for(int column=cmatrix_middle; column<nColumns-cmatrix_middle; column++) {
			sum = 0;
			for(int j=0; j<cmatrix_length; j++) {
				sum += src_row[column + j-cmatrix_middle] * cmatrix[j];
			}
			dest_row[column] = float(sum);
		}
		// for the edge condition , we only use available info, and scale to one
		for(int column=nColumns-cmatrix_middle; column<nColumns; column++) {
			// find scale factor
			scale=0;
			for(int j=0; j<nColumns-column+cmatrix_middle; j++)
				scale += cmatrix[j];
			sum = 0;
			for(int j=0; j<nColumns-column+cmatrix_middle; j++) {
				sum += src_row[column + j-cmatrix_middle] * cmatrix[j];
			}
			dest_row[column] = float(sum / scale);
		}
  }
}


////////////////////////////////////////////////////////////////////////////////
//
// \author [nipper], adapted [GS]
//
void
CProjection::blur_column(float *cmatrix, int cmatrix_length, float* src_col, float* dest_col, int nRows, int nColumns) {
	float scale, sum;
  int cmatrix_middle = cmatrix_length/2;
	
	if(cmatrix_length > nRows) {
		for(int row=0; row<nRows; row++) {
			scale = 0;
			// find the scale factor
			for(int j=0; j<nRows; j++) {
				// if the index is in bounds, add it to the scale counter
				if((j + cmatrix_middle - row >= 0) &&
					 (j + cmatrix_middle - row < cmatrix_length))
					scale += cmatrix[j + cmatrix_middle - row];
			}
			sum = 0;
			for(int j=0; j<nRows; j++) {
				if((j >= row - cmatrix_middle) &&
					 (j <= row + cmatrix_middle))
					sum += src_col[j*nColumns] * cmatrix[j];
			}
			dest_col[row] = float(sum / scale);
		}
  } else {
		// for the edge condition, we only use available info and scale to one
		for(int row=0; row<cmatrix_middle; row++) {
			// find scale factor
			scale=0;
			for(int j=cmatrix_middle-row; j<cmatrix_length; j++)
				scale += cmatrix[j];
	    sum = 0;
			for(int j=cmatrix_middle-row; j<cmatrix_length; j++) {
        sum += src_col[(row + j-cmatrix_middle)*nColumns] * cmatrix[j];
			}
			dest_col[row*nColumns] = float(sum / scale);
		}
		// go through each pixel
		for(int row=cmatrix_middle; row<nRows-cmatrix_middle; row++) {
			sum = 0;
			for(int j=0; j<cmatrix_length; j++) {
				sum += src_col[(row + j-cmatrix_middle)*nColumns] * cmatrix[j];
			}
			dest_col[row] = float(sum);
		}
    // for the edge condition , we only use available info, and scale to one
		for(int row=nRows-cmatrix_middle; row<nRows; row++) {
			// find scale factor
			scale=0;
			for(int j=0; j<nRows-row+cmatrix_middle; j++)
				scale += cmatrix[j];
			sum = 0;
			for(int j=0; j<nRows-row+cmatrix_middle; j++) {
				sum += src_col[(row + j-cmatrix_middle)*nColumns] * cmatrix[j];
			}
			dest_col[row] = float(sum / scale);
		}
  }
}


void 
CProjection::bSort(float *a, int n) {
  int i,j;
  float tmp;
  for(i=0; i<n-1; i++) {
    for(j=0; j<n-1-i; j++)
      if(a[j+1] < a[j]) {  /* compare the two neighbors */
        tmp = a[j];         /* swap a[j] and a[j+1]      */
        a[j] = a[j+1];
        a[j+1] = tmp;
    }
  }
}


bool
CProjection::Copy(CProjection& P2Copy) {
  if(!P2Copy.IsInitialized()) {
   sErrorString.Format(_T("Error: Not Initialized"));
   return false;
  }
  if(!IsInitialized()) {
    n_columns = P2Copy.n_columns;
    n_rows = P2Copy.n_rows;
    pData = new float[n_rows*n_columns];
  } else {
    float* pTmp = new float[P2Copy.n_columns*P2Copy.n_rows];
    if(pTmp == NULL) {
     sErrorString.Format(_T("Not Enough Memory"));
     return false;
    } else {
      delete[] pData;
      pData = pTmp;
      n_columns = P2Copy.n_columns;
      n_rows = P2Copy.n_rows;
    }
  }
  for(int i=0; i<n_rows*n_columns; i++) {
    *(pData+i) = *(P2Copy.pData+i);
  }
  sErrorString = _T("No error");
	return true;
}


bool
CProjection::Sum(CProjection& P2Add) {
  if(!P2Add.IsInitialized()) {
   sErrorString.Format(_T("Error: Not Initialized"));
   return false;
  }
  if(!IsInitialized()) {
    n_columns = P2Add.n_columns;
    n_rows = P2Add.n_rows;
    pData = new float[n_rows*n_columns];
  } else {
    if((n_columns != P2Add.n_columns) || (n_rows != P2Add.n_rows)) {
     sErrorString.Format(_T("Different Size"));
     return false;
    }
  }
  for(int i=0; i<n_rows*n_columns; i++) {
    *(pData+i) += *(P2Add.pData+i);
  }
  sErrorString = _T("No error");
	return true;
}


bool
CProjection::Subtract(CProjection& P2Subtract) {
  if(!P2Subtract.IsInitialized()) {
   sErrorString.Format(_T("Error: Not Initialized"));
   return false;
  }
  if(!IsInitialized()) {
    n_columns = P2Subtract.n_columns;
    n_rows = P2Subtract.n_rows;
    pData = new float[n_rows*n_columns];
  } else {
    if((n_columns != P2Subtract.n_columns) || (n_rows != P2Subtract.n_rows)) {
     sErrorString.Format(_T("Different Size"));
     return false;
    }
  }
  for(int i=0; i<n_rows*n_columns; i++) {
    *(pData+i) -= *(P2Subtract.pData+i);
  }
  sErrorString = _T("No error");
	return true;
}


bool
CProjection::LinTransform(float factor, float offset) {
  if(!IsInitialized()) {
   sErrorString.Format(_T("Error: Not Initialized"));
   return false;
  }
  for(int i=0; i<n_rows*n_columns; i++) {
    *(pData+i) = (*(pData+i) - offset) * factor;
  }
  sErrorString = _T("No error");
	return true;
}


bool
CProjection::GetMinMax(float* min, float* max) {
  if(!IsInitialized()) {
   sErrorString.Format(_T("Error: Not Initialized"));
   return false;
  }
  *min = FLT_MAX;
  *max =-FLT_MAX;
  for(int x=0; x<n_rows*n_columns; x++) {
    if(!_finite(double(*(pData+x))))
      *min = *min;
    if(*(pData+x) < *min) *min = *(pData+x);
    if(*(pData+x) > *max) *max = *(pData+x);
  }
  sErrorString = _T("No error");
	return true;
}


bool
CProjection::GetPixelsSum(float* PixelsSum){

 if(!IsInitialized()) {
   sErrorString.Format(_T("Error: Not Initialized"));
   return false;
  }
  *PixelsSum = 0.0f;
  
  for(int x=0; x<n_rows*n_columns; x++) {
    if(_finite(double(*(pData+x))))
      *PixelsSum += *(pData+x);
  }
  sErrorString = _T("No error");
	return true;
}


bool
CProjection::Reset(void) {
  if(IsInitialized()) {
    delete[] pData;
  }
  pData           = NULL;
  n_rows          = 0;
  n_columns       = 0;
  f_TimeOfFlight  = FLOAT_UNDEFINED;
  f_angle         = FLOAT_UNDEFINED;
  f_BeamIntensity = FLOAT_UNDEFINED;
  f_PosX          = FLOAT_UNDEFINED;
  f_PosY          = FLOAT_UNDEFINED;
  f_PosZ          = FLOAT_UNDEFINED;
  i_SliceNum      = INT_UNDEFINED;
  sErrorString    = _T("No error");
  return true;
}


bool
CProjection::FlatFieldCorr(CProjection& Beam, CProjection& Dark) {
  if(!IsInitialized() || !Beam.IsInitialized() || !Dark.IsInitialized()) {
    sErrorString = _T("Projection Uninitalized");
    return false;
  }
  //Flat Field Correction
  float den;
  for(int y=0; y<n_rows*n_columns; y++) {
    den = (*(Beam.pData+y)  - (*(Dark.pData+y)));
    if(den > FLT_MIN)
      *(pData+y) = (*(pData+y) - (*(Dark.pData+y))) / den;
    else if(*(Beam.pData+y) > FLT_MIN)
      *(pData+y) /= *(Beam.pData+y);
    if(*(pData+y) < 0.0) 
      *(pData+y) = 0.0;
  }
  sErrorString = _T("No error");
  return true;
}


bool
CProjection::FlatFieldCorr(CProjection& Beam) {
  if(!IsInitialized() || !Beam.IsInitialized()) {
    sErrorString = _T("Projection Uninitalized");
    return false;
  }
  //Flat Field Correction    
  for(int y=0; y<n_rows*n_columns; y++) {
    if(*(Beam.pData+y) > FLT_MIN)
      *(pData+y) /= *(Beam.pData+y);
    if(*(pData+y) < 0.0)
      *(pData+y) = 0.0;
  }
  sErrorString = _T("No error");
  return true;
}


bool
CProjection::OpenBeamCorr(int x0, int x1, int y0, int y1) {
  if(!IsInitialized()) {
    sErrorString = _T("Projection Uninitalized");
    return false;
  }
  float fSum = 0.0;
  int nPix = 0, yOff;
  for(int y=y0; y<y1; y++) {
    yOff = y*n_columns;
    for(int x=x0; x<x1; x++) {
      fSum += *(pData+yOff+x);
      nPix++;
    }
  }
  fSum /= float(nPix);
  if(fSum <= 0.0) fSum = 1.0;

  float fVal;
  for(int y=0; y<n_rows*n_columns; y++) {
    fVal = *(pData+y);
    if(fVal <= 0.0f) 
      fVal = 0.4f;
    fVal = log(fSum/fVal);
    *(pData+y) = fVal;
  }
  sErrorString = _T("No error");
  return true;
}


bool
CProjection::OpenBeamCorr(float fBeam) {
  if(!IsInitialized()) {
    sErrorString = _T("Projection Uninitalized");
    return false;
  }
  if(fBeam <= 0.0) {
    sErrorString = _T("Illegal Beam Value");
    return false;
  }

  float fVal;
  for(int y=0; y<n_rows*n_columns; y++) {
    fVal = *(pData+y);
    if(fVal <= 0.0f) { 
      *(pData+y) = FLT_MAX;
      continue;
    } 
    fVal = log(fBeam/fVal);
    *(pData+y) = fVal;
  }
  sErrorString = _T("No error");
  return true;
}


// Create a FITS primary array containing a 2-D image
bool
CProjection::WriteToFitsFile(CString sDirectory, CString sFileName) {
  if(!IsInitialized()) {
    sErrorString = _T("Projection Uninitalized");
    return false;
  }

  fitsfile *fitsFilePtr;
  int iStatus = 0;

  char cFilename[MAX_PATH];
  wcstombs(cFilename, sDirectory+_T("\\") + sFileName, sizeof(cFilename));// name for new FITS file
 
  int bitpix    =  FLOAT_IMG;// 32-bit float pixel values
  long naxis    =   2;       // 2-dimensional image
  long naxes[2] = { n_columns, n_rows };

  if(PathFileExistsA(cFilename)) {
    remove(cFilename);// Delete old file if it already exists
  }

  if(fits_create_file(&fitsFilePtr, cFilename, &iStatus)) {// create new FITS file
    SetErrorString(iStatus);
    return false;
  }

  if(fits_create_img(fitsFilePtr, bitpix, naxis, naxes, &iStatus)) {
    SetErrorString(iStatus);          
    return false;
  }

  if(fits_write_img(fitsFilePtr, TFLOAT, 1, naxes[0]*naxes[1], pData, &iStatus)) {
    SetErrorString(iStatus);
    return false;
  }

  if(!WriteKeys(fitsFilePtr)) {
    SetErrorString(iStatus);
    fits_close_file(fitsFilePtr, &iStatus);
    return false;
  }

  if(fits_close_file(fitsFilePtr, &iStatus)) {
    SetErrorString(iStatus);
    return false;
  }

  return true;
}


bool
CProjection::WriteKeys(fitsfile* fitsFilePtr) {
  int iStatus = 0;
  int iRes;
  float fVal;

  if(f_TimeOfFlight == FLOAT_UNDEFINED) {
    iRes = fits_delete_key(fitsFilePtr, "GATEDELY", &iStatus);
    iRes = fits_delete_key(fitsFilePtr, "TOF", &iStatus);
    iStatus = 0;
  } else {
    fVal = f_TimeOfFlight * 1.0e-15f;
    iRes = fits_update_key(fitsFilePtr, TFLOAT, "GATEDELY", &fVal, "Gate delay", &iStatus);
  }

  if(f_angle == FLOAT_UNDEFINED) {
    iRes = fits_delete_key(fitsFilePtr, "ANGPOS", &iStatus);
    iStatus = 0;
  } else {
    iRes = fits_update_key(fitsFilePtr, TFLOAT, "ANGPOS", &f_angle, "Angular Position Degree", &iStatus);
  }

  if(f_BeamIntensity == FLOAT_UNDEFINED) {
    iRes = fits_delete_key(fitsFilePtr, "CURRENT", &iStatus);
    iStatus = 0;
  } else {
    iRes = fits_update_key(fitsFilePtr, TFLOAT, "CURRENT", &f_BeamIntensity, "Total Beam Current uA", &iStatus);
  }

  if(f_PosX == FLOAT_UNDEFINED) {
    iRes = fits_delete_key(fitsFilePtr, "X_POS", &iStatus);
    iStatus = 0;
  } else {
    iRes = fits_update_key(fitsFilePtr, TFLOAT, "X_POS", &f_PosX, "X Position mm", &iStatus);
  }

  if(f_PosY == FLOAT_UNDEFINED) {
    iRes = fits_delete_key(fitsFilePtr, "Y_POS", &iStatus);
    iStatus = 0;
  } else {
    iRes = fits_update_key(fitsFilePtr, TFLOAT, "Y_POS", &f_PosY, "Y Position mm", &iStatus);
  }

  if(f_PosZ == FLOAT_UNDEFINED) {
    iRes = fits_delete_key(fitsFilePtr, "Z_POS", &iStatus);
    iStatus = 0;
  } else {
    iRes = fits_update_key(fitsFilePtr, TFLOAT, "Z_POS", &f_PosZ, "Z Position mm", &iStatus);
  }

  if(i_SliceNum == FLOAT_UNDEFINED) {
    iRes = fits_delete_key(fitsFilePtr, "SLICENUM", &iStatus);
    iStatus = 0;
  } else {
    iRes = fits_update_key(fitsFilePtr, TINT, "SLICENUM", &i_SliceNum, "Slice Number", &iStatus);
  }

  fits_clear_errmsg();
  return true;
}


void
CProjection::SetErrorString(const int status) {
  char status_str[FLEN_STATUS], errmsg[FLEN_ERRMSG];
  CString sString;
  if(status) {
    // get the error description
    fits_get_errstatus(status, status_str);
    sErrorString.Format(_T("\r\nFITSIO status = %d: %s\r\n"), status, CString(status_str));
    // get error stack messages
    while(fits_read_errmsg(errmsg))  {
      sString.Format(_T("%s\r\n"), CString(errmsg));
      sErrorString += sString;
    }
  }
}


bool
CProjection::ReadFromFitsFile(CString sPathName) {
  fitsfile *fitsFilePtr;
  int iStatus=0;
  int iScaling = 1;
  char filename[MAX_PATH];

  wcstombs(filename, sPathName, MAX_PATH);
  if(fits_open_file(&fitsFilePtr, filename, READONLY, &iStatus)) {
    SetErrorString(iStatus);
    return false;
  }

  int nHdu;
  if(fits_get_num_hdus(fitsFilePtr, &nHdu, &iStatus)) {
    SetErrorString(iStatus);
    return false;
  }
  if(nHdu != 1) {
    sErrorString = _T("Numero di HDU > 1");
    return false;
  }

  int HduType;
  if(fits_get_hdu_type(fitsFilePtr, &HduType, &iStatus)) {
    SetErrorString(iStatus);
    return false;
  }
  if(HduType != IMAGE_HDU) {
    sErrorString.Format(_T("File: %s\r\n is NOT an Image !"), sPathName);
    return false;
  }

  int nAxes;
  if(fits_get_img_dim(fitsFilePtr, &nAxes, &iStatus)) {
    SetErrorString(iStatus);
    return false;
  }

  int imgType;
  if(fits_get_img_type(fitsFilePtr, &imgType, &iStatus)) {
    SetErrorString(iStatus);
    return false;
  }
  
  long* axisDim = new long[nAxes]; 
  if(fits_get_img_size(fitsFilePtr, 2, axisDim, &iStatus)) {
    SetErrorString(iStatus);
    return false;
  }

  n_columns = axisDim[0]/iScaling;
  n_rows    = axisDim[1]/iScaling;

  long firstPixel[] = {1, 1, 1};
  int dataType;
  if(pData) delete[] pData;
  pData = new float[axisDim[0]*axisDim[1]];
  void *pImage;

  switch(imgType) {
    case BYTE_IMG:
      dataType = TBYTE;
      pImage = new BYTE[axisDim[0]*axisDim[1]];
      if(fits_read_pix(fitsFilePtr, dataType, firstPixel, axisDim[0]*axisDim[1], NULL, pImage, NULL, &iStatus)) {
        SetErrorString(iStatus);
        return false;
      }
      for(int y=0; y<n_rows; y++) {
        for(int x=0; x<n_columns; x++) {
          *(pData+y*n_columns+x) = float(*((BYTE *)pImage+iScaling*(y*axisDim[0]+x)));
        }
      }
      delete[] pImage;
      break;
    case SHORT_IMG: 
      dataType = TUSHORT;
      pImage = new unsigned short[axisDim[0]*axisDim[1]];
      if(fits_read_pix(fitsFilePtr, dataType, firstPixel, axisDim[0]*axisDim[1], NULL, pImage, NULL, &iStatus)) {
        SetErrorString(iStatus);
        return false;
      }
      for(int y=0; y<n_rows; y++) {
        for(int x=0; x<n_columns; x++) {
          *(pData+y*n_columns+x) = float(*((unsigned short *)pImage+iScaling*(y*axisDim[0]+x)));
        }
      }
      delete[] pImage;
      break;
    case LONG_IMG: 
      dataType = TUINT;
      pImage = new unsigned int[axisDim[0]*axisDim[1]];
      if(fits_read_pix(fitsFilePtr, dataType, firstPixel, axisDim[0]*axisDim[1], NULL, pImage, NULL, &iStatus)) {
        SetErrorString(iStatus);
        return false;
      }
      for(int y=0; y<n_rows; y++) {
        for(int x=0; x<n_columns; x++) {
          *(pData+y*n_columns+x) = float(*((unsigned int *)pImage+iScaling*(y*axisDim[0]+x)));
        }
      }
      delete[] pImage;
      break;
    case FLOAT_IMG: 
      dataType = TFLOAT;
      if(fits_read_pix(fitsFilePtr, dataType, firstPixel, axisDim[0]*axisDim[1], NULL, pData, NULL, &iStatus)) {
        SetErrorString(iStatus);
        return false;
      }
      break;
    case DOUBLE_IMG: 
      dataType = TDOUBLE;
      pImage = new double[axisDim[0]*axisDim[1]];
      if(fits_read_pix(fitsFilePtr, dataType, firstPixel, axisDim[0]*axisDim[1], NULL, pImage, NULL, &iStatus)) {
        SetErrorString(iStatus);
        return false;
      }
      for(int y=0; y<n_rows; y++) {
        for(int x=0; x<n_columns; x++) {
          *(pData+y*n_columns+x) = float(*((double *)pImage+iScaling*(y*axisDim[0]+x)));
        }
      }
      delete[] pImage;
      break;
    default:
      sErrorString.Format(_T("File: %s\r\n has an unknown format"), sPathName);
      return false;
  }
  delete[] axisDim;  

  if(!ReadKeys(fitsFilePtr)) {
    fits_close_file(fitsFilePtr, &iStatus);
    return false;
  }

  if(fits_close_file(fitsFilePtr, &iStatus)) {
    SetErrorString(iStatus);
    return false;
  }
  sErrorString = _T("No error");
  return true;
}


bool
CProjection::ReadKeys(fitsfile* fitsFilePtr) {
  int iStatus=0;
  int iRes;

  f_TimeOfFlight  = FLOAT_UNDEFINED;
  f_angle         = FLOAT_UNDEFINED;
  f_BeamIntensity = FLOAT_UNDEFINED;
  f_PosX          = FLOAT_UNDEFINED;
  f_PosY          = FLOAT_UNDEFINED;
  f_PosZ          = FLOAT_UNDEFINED;
  i_SliceNum      = INT_UNDEFINED;

  iRes = fits_read_key(fitsFilePtr, TFLOAT, "GATEDELY", &f_TimeOfFlight, NULL, &iStatus);
  iStatus = 0;
  if(!iRes) f_TimeOfFlight *= 1.0e15f;
  iRes = fits_read_key(fitsFilePtr, TFLOAT, "TOF", &f_TimeOfFlight, NULL, &iStatus);
  iStatus = 0;
  if(!iRes) f_TimeOfFlight *= 1.0e6f;
  iRes = fits_read_key(fitsFilePtr, TFLOAT, "ANGPOS", &f_angle, NULL, &iStatus);
  iStatus = 0;
  iRes = fits_read_key(fitsFilePtr, TFLOAT, "CURRENT", &f_BeamIntensity, NULL, &iStatus);
  iStatus = 0;
  iRes = fits_read_key(fitsFilePtr, TFLOAT, "X_POS", &f_PosX, NULL, &iStatus);
  iStatus = 0;
  iRes = fits_read_key(fitsFilePtr, TFLOAT, "Y_POS", &f_PosY, NULL, &iStatus);
  iStatus = 0;
  iRes = fits_read_key(fitsFilePtr, TFLOAT, "Z_POS", &f_PosZ, NULL, &iStatus);
  iStatus = 0;
  iRes = fits_read_key(fitsFilePtr, TINT, "SLICENUM", &i_SliceNum, NULL, &iStatus);
  iStatus = 0;

  return true;
}


bool
CProjection::VerticalFlip(void){
  if(!IsInitialized()) {
    sErrorString = _T("Projection Uninitalized");
    return false;
  }
  float* pTemp = new float[n_columns*n_rows];
  if(pTemp == NULL) {
    sErrorString = _T("Not Enough Memory to Flip Image");
    return false;
  }
  int iOff = n_columns*n_rows-1;
  for(int i=0; i<n_columns*n_rows; i++)
    *(pTemp+i) = *(pData+iOff-i);
  delete[] pData;
  pData = pTemp;
  sErrorString = _T("No error");
  return true;
}


bool
CProjection::HorizontalFlip(void) {
  if(!IsInitialized()) {
    sErrorString = _T("Projection Uninitalized");
    return false;
  }
  float* pTemp = new float[n_columns*n_rows];
  if(pTemp == NULL) {
    sErrorString = _T("Not Enough Memory to Create Mirror Image");
    return false;
  }
  int Off;
  for(int y=0; y<n_rows; y++) {
    Off = y*n_columns;
    for(int x=0; x<n_columns; x++) {
      *(pTemp+Off+n_columns-x-1) = *(pData+Off+x);
    }
  }
  delete[] pData;
  pData = pTemp;
  sErrorString = _T("No error");
  return true;
}


bool
CProjection::ClearImage(void) {
  if(!IsInitialized()) {
    sErrorString = _T("Projection Uninitalized");
    return false;
  }
  ZeroMemory(pData, n_columns*n_rows*sizeof(*pData));
  return true;
}


bool
CProjection::Rotate(float angle){// In radians
  if(!IsInitialized()) {
    sErrorString = _T("Projection Uninitalized");
    return false;
  }
	float fmin, fmax;
  GetMinMax(&fmin, &fmax);
	float cos_angle = (float) cos(angle);			//these two are needed later (to rotate)
	float sin_angle = (float) sin(angle);
	
	//Calculate the size of the new bitmap (rotate corners of image)
	CPoint2f p[4];								//original corners of the image
	p[0]=CPoint2f(-0.5f, -0.5f);
	p[1]=CPoint2f(n_columns-0.5f, -0.5f);
	p[2]=CPoint2f(-0.5f, n_rows-0.5f);
	p[3]=CPoint2f(n_columns-0.5f, n_rows-0.5f);

	CPoint2f newp[4];								//rotated positions of corners
	//(rotate corners)
	for (int i=0; i<4; i++) {
		newp[i].x = (p[i].x*cos_angle - p[i].y*sin_angle);
		newp[i].y = (p[i].x*sin_angle + p[i].y*cos_angle);
	}//for i

	//(read new dimensions from location of corners)
	float minx = (float) min(min(newp[0].x,newp[1].x),min(newp[2].x,newp[3].x));
	float miny = (float) min(min(newp[0].y,newp[1].y),min(newp[2].y,newp[3].y));
	float maxx = (float) max(max(newp[0].x,newp[1].x),max(newp[2].x,newp[3].x));
	float maxy = (float) max(max(newp[0].y,newp[1].y),max(newp[2].y,newp[3].y));
	int newWidth = (int) floor(maxx-minx+0.5f);
	int newHeight= (int) floor(maxy-miny+0.5f);

	float newxcenteroffset = 0.5f * newWidth;
	float newycenteroffset = 0.5f * newHeight;

	float ssx=((maxx+minx)- ((float) newWidth-1))/2.0f;   //start for x
	float ssy=((maxy+miny)- ((float) newHeight-1))/2.0f;  //start for y

	//create destination image
	CProjection* p_imgDest;
  p_imgDest = new CProjection(newWidth, newHeight);

	float x, y;             //destination location (float, with proper offset)
	float origx, origy;     //origin location
	int destx, desty;       //destination location
  int ox, oy;
  float *pxptr;

  y = ssy;                //initialize y
  for(desty=0; desty<newHeight; desty++) {
		x = ssx;//initialize x
		pxptr = p_imgDest->pData+desty*newWidth;//pointer to first byte in row
    for(destx=0; destx<newWidth; destx++) {
			//get source pixel coordinate for current destination point
			origx = cos_angle*x + sin_angle*y;
			origy = cos_angle*y - sin_angle*x;
      ox = int(origx+0.5f);
      oy = int(origy+0.5f);
      *pxptr++ = GetPixelColorInterpolated(origx, origy, fmin);
			x++;
		}//for destx
		y++;
	}//for desty

  //select the destination
  int x0, y0;
  x0 = int((newWidth-n_columns)*0.5);
  y0 = int((newHeight-n_rows)*0.5);
  p_imgDest->Crop(x0, x0+n_columns, y0, y0+n_rows);
  p_imgDest->GetMinMax(&fmin, &fmax);
  CopyMemory(pData, p_imgDest->pData, p_imgDest->n_rows*p_imgDest->n_columns*sizeof(*p_imgDest->pData));

  delete p_imgDest;

	return true;
}


float
CProjection::GetPixelColorInterpolated(float x, float y, float rplColor) {

  int xi = (int)(x); if(x<0) xi--;   //these replace (incredibly slow) floor 
  int yi = (int)(y); if(y<0) yi--;   //(Visual c++ 2003, AMD Athlon)
  float color;

  //bilinear interpolation
  if(xi<-1 || xi>=n_columns || yi<-1 || yi>=n_rows) {// all 4 points are outside bounds
    //we don't need to interpolate anything with all points outside in this case
    return rplColor;
  }//if

  float t1 = x - xi;
  float t2 = y - yi;
  float d  = t1 * t2;
  float b  = t1 - d;
  float c  = t2 - d;
  float a  = 1.0f - t1 - c;
  //get four neighbouring pixels
  if((xi+1)<n_columns && xi>=0 && (yi+1)<n_rows && yi>=0) {
    //all pixels are inside the image
    float *pxptr = pData + yi*n_columns + xi;
    color  = a * (*pxptr++);
    color += b * (*pxptr);
    pxptr += n_columns - 1; //move to next row
    color += c * (*pxptr++); 
    color += d * (*pxptr); 
  } else {
    //default (slower) way to get pixels (some pixels out of borders)
    float rgb11, rgb21, rgb12, rgb22;
    rgb11 = GetPixelColorWithOverflow(xi,   yi,   rplColor);
    rgb21 = GetPixelColorWithOverflow(xi+1, yi,   rplColor);
    rgb12 = GetPixelColorWithOverflow(xi,   yi+1, rplColor);
    rgb22 = GetPixelColorWithOverflow(xi+1, yi+1, rplColor);
    //calculate linear interpolation
    color = a*rgb11 + b*rgb21 + c*rgb12 + d*rgb22;
  }//if
  return color;

}


float
CProjection::GetPixelColorWithOverflow(int x, int y, float rplColor) {
  float fval;
  if((x > -1) && (x < n_columns) && (y > -1) && (y < n_rows)) {
    fval = *(pData+y*n_columns+x);
  } else {
    fval = rplColor;
  }
  return fval;
}


bool
CProjection::ShiftRows(int nRows) {
  if(!nRows) return true;
  if(!IsInitialized()) {
    sErrorString = _T("Projection Uninitalized");
    return false;
  }
  if(nRows > 0) {
    for(int i=0; i<(n_rows-nRows)*n_columns; i++) {
      *(pData+i) = *(pData+i+nRows*n_columns);
    }
  } else {
    nRows = -nRows;
    int j;
    for(int i=n_rows*n_columns-1; i>=nRows*n_columns; i--) {
      j = i - nRows*n_columns;
      *(pData+i) = *(pData+j);
    }
  }
  return false;
}

