#include "StdAfx.h"
#include "float.h"  // per FLT_MAX
#include "Resource.h"
#include "Projection.h"
#include "NeuTomoUtil.h"
#include "MsgWindow.h"
#include "VolumeWnd.h"
#include "./include/hpmc.h"

using std::string;

std::string shaded_vertex_shader =
        "uniform vec4 l1;\n"
        "uniform vec4 l2;\n"
        "varying vec3 normal;\n"
        "varying vec3 light1;\n"
        "varying vec3 light2;\n"
        "void\n"
        "main()\n"
        "{\n"
        "    vec3 p, n;\n"
        "    light1 = vec3(gl_ModelViewProjectionMatrixInverse * l1);\n"
        "    light2 = vec3(gl_ModelViewProjectionMatrixInverse * l2);\n"
        "    extractVertex(p, n);\n"// Function generated by the HPMC library
        "    gl_Position = gl_ModelViewProjectionMatrix * vec4(p, 1.0);\n"
        "    normal = gl_NormalMatrix * n;\n"
        "    gl_FrontColor = gl_Color;\n"
        "}\n";


std::string shaded_fragment_shader =
        "varying vec3 normal;\n"
        "varying vec3 light1;\n"
        "varying vec3 light2;\n"
        "void\n"
        "main()\n"
        "{\n"
        "    vec3 v = normalize(light1);\n"
        "    vec3 l = normalize(light2);\n"
        "    vec3 h = normalize(v+l);\n"
        "    vec3 n = normalize(normal);\n"
        "    float diff = max(0.3, abs(dot(n, l)));\n"
        "    float spec = pow(max(0.0, dot(n, h)), 20.0);\n"
        "    gl_FragColor = diff * gl_Color +\n"
        "                   spec * vec4(1.0);\n"
        "}\n";


// --- compile shader and check for errors -------------------------------------
void
compileShader(GLuint shader, const string& what) {
  CString sLine;
  _TCHAR* tString;
  glCompileShader(shader);
  GLint compile_status;
  glGetShaderiv(shader, GL_COMPILE_STATUS, &compile_status);
  if(compile_status != GL_TRUE) {
    tString = new _TCHAR[what.length()+1];
    mbstowcs(tString, what.c_str(), what.length()+1);
    CMsgWindow MsgWindow(_T("Log Window"));
    sLine.Format(_T("Compilation of  %s failed, infolog:\r\n"), tString);
    MsgWindow.AddText(sLine);
    delete[] tString;

    GLint logsize;
    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &logsize);

    if(logsize > 0){
      char* infolog= new char[logsize+1];
      glGetShaderInfoLog(shader, logsize, NULL, infolog);
      tString = new _TCHAR[strlen(infolog)+1];
      mbstowcs(tString, infolog, strlen(infolog)+1);
      sLine.Format(_T("%s\r\n"), tString);
      MsgWindow.AddText(sLine);
      delete[] tString;
      delete[] infolog;
    }
    else {
      MsgWindow.AddText(_T("Empty log message\r\n"));
    }
    MsgWindow.AddText(_T("Exiting.\r\n"));
    AfxMessageBox(_T("Press OK"), MB_ICONSTOP);
    exit(EXIT_FAILURE);
  }
}


// --- compile program and check for errors ------------------------------------
void
linkProgram(GLuint program, const string& what) {
  CString sLine;
  _TCHAR* tString;
  glLinkProgram(program);

  GLint linkstatus;
  glGetProgramiv(program, GL_LINK_STATUS, &linkstatus);
  if(linkstatus != GL_TRUE){
    tString = new _TCHAR[what.length()+1];
    mbstowcs(tString, what.c_str(), what.length()+1);
    CMsgWindow MsgWindow(_T("Log Window"));
    sLine.Format(_T("Linking of %s failed, infolog:"), tString);
    MsgWindow.AddText(sLine);
    delete[] tString;

    GLint logsize;
    glGetProgramiv(program, GL_INFO_LOG_LENGTH, &logsize);

    if(logsize > 0){
      char* infolog= new char[logsize+1];
      glGetProgramInfoLog(program, logsize, NULL, infolog);
      tString = new _TCHAR[strlen(infolog)+1];
      mbstowcs(tString, infolog, strlen(infolog)+1);
      sLine.Format(_T("%s\r\n"), tString);
      MsgWindow.AddText(sLine);
      delete[] tString;
      delete[] infolog;
    }
    else {
      MsgWindow.AddText(_T("Empty log message\r\n"));
    }
    MsgWindow.AddText(_T("Exiting.\r\n"));
    AfxMessageBox(_T("Press OK"), MB_ICONSTOP);
    exit(EXIT_FAILURE);
  }
}


CVolumeWnd::CVolumeWnd(CString Title, int xSize, int ySize, CWnd* pParent)
  : myTitle(Title)
  , pMyParent(pParent)
  , xPos(50), yPos(50)
  , width(xSize), height(ySize)
  , bShowFrame(false)
  , iso(0.30)
  , red(1.0)
  , green(1.0)
  , blue(0.3)
  //, hpmc_th_shaded(NULL)
  //, hpmc_c(NULL)
  //, hpmc_h(NULL)
  , volume_tex(0)
{
  UINT cStyle= CS_DBLCLKS | CS_HREDRAW | CS_NOCLOSE | CS_VREDRAW;
  CBrush myBrush(RGB(0, 0, 0));
  HBRUSH hbrBackground = HBRUSH(myBrush);
  HICON hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
  CString ClassName = AfxRegisterWndClass(cStyle, NULL, hbrBackground, hIcon); 
  DWORD exStyle = WS_EX_DLGMODALFRAME;
  DWORD Style = WS_OVERLAPPEDWINDOW;
  BOOL result = CreateEx(exStyle, ClassName, _T("Volume Window"), Style, xPos, yPos, width, height, NULL, NULL, 0);
  if(!result){
    AfxMessageBox(_T("CVolumeWnd CreateEx(...)failed"));
    PostQuitMessage(-1);
  } // if(!result)

  m_camera.Set(0.0, 0.0, 2.5, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);
  m_camera.FieldOfView(30.0);
  m_camera.MouseMode(CGrCamera::PITCHYAW);
  m_camera.Gravity(false);

  aspect_x = 1.0;
  aspect_y = 1.0;
  dx       = 0.0f;
  dy       = 0.0f;
  dz       = 0.0f;
}


CVolumeWnd::~CVolumeWnd(void) {
  if(hpmc_th_shaded) HPMCdestroyTraversalHandle(hpmc_th_shaded);
  if(hpmc_c) HPMCdestroyConstants(hpmc_c);
  //??????????????????????????? if(hpmc_h) HPMCdestroyHandle(hpmc_h);
  if(volume_tex) glDeleteTextures(1, &volume_tex);
}


BEGIN_MESSAGE_MAP(CVolumeWnd, COpenGLCtrl)
  ON_WM_MOUSEMOVE()
  ON_WM_LBUTTONDOWN()
  ON_WM_LBUTTONUP()
  ON_WM_RBUTTONDOWN()
  ON_WM_RBUTTONUP()
  ON_WM_MOUSEWHEEL()

END_MESSAGE_MAP()


void 
CVolumeWnd::OnPrepareRC() {
  int err = glewInit();
  if(err != GLEW_OK) {// sanity check
    char* cString = (char *)glewGetErrorString(err);
    _TCHAR* tString = new _TCHAR[strlen(cString)+1];
    mbstowcs(tString, cString, strlen(cString));
    tString[strlen(cString)] = 0;
    AfxMessageBox(tString, MB_ICONSTOP);
    delete[] tString;
  } // if(GLEW_OK != err)
}


void
CVolumeWnd::SetShowFrame(int ShowFrame) {
  bShowFrame = (ShowFrame != 0);
  RedrawOpenGLWindow();
}



void
CVolumeWnd::CustomizePixelFormat(PIXELFORMATDESCRIPTOR* pfd) {
  pfd->dwFlags |= PFD_DOUBLEBUFFER;
}


bool 
CVolumeWnd::LoadVolume(CString sPath) {
// New
  MEMORYSTATUSEX MemStat;
  // Initialize the structure
  memset(&MemStat, 0, sizeof(MemStat));
  MemStat.dwLength = sizeof(MemStat);
  // Get RAM snapshot
  ::GlobalMemoryStatusEx(&MemStat);
  int availableRam_kb = MemStat.ullAvailPhys/1024;
  GLint cur_avail_graphic_mem_kb = 0;
  glGetIntegerv(GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX, &cur_avail_graphic_mem_kb);
//End New

  WIN32_FIND_DATA FileData;
  HANDLE hSearch;
  CString sString;
  CString sPathName, sFileDati;
  CString sDirectory = sPath;// The slices directory 
  sPathName = sDirectory + _T("\\*.fits");

  float fMin = FLT_MAX, fMax =-FLT_MAX;
  float rMin = FLT_MAX, rMax =-FLT_MAX;
  int nProjections = 0;

  CWaitCursor WaitCursor;
  sString = _T("Checking Directory Content");
  if(pMyParent != NULL)
    pMyParent->SendMessage(MSG_STATUS_MESSAGE, 0, (LPARAM)&sString);

  hSearch = FindFirstFile(sPathName, &FileData);
  if(hSearch == INVALID_HANDLE_VALUE){
    AfxMessageBox(_T("Invalid Path\n")+sPathName, MB_ICONSTOP);
    return false;
  }
  sFileDati = FileData.cFileName;
  CProjection ProjTemp;
  if(!ProjTemp.ReadFromFitsFile(sDirectory+_T("\\")+sFileDati)){
    AfxMessageBox(ProjTemp.sErrorString, MB_ICONSTOP);
    return false;
  }
  volume_size_x = ProjTemp.n_columns;
  volume_size_y = ProjTemp.n_rows;
  ProjTemp.GetMinMax(&fMin, &fMax);
  nProjections++;
  while(FindNextFile(hSearch, &FileData)){
    sFileDati = FileData.cFileName;
    if(!ProjTemp.ReadFromFitsFile(sDirectory+_T("\\")+sFileDati)){
      AfxMessageBox(ProjTemp.sErrorString, MB_ICONSTOP);
      return false;
    }
    ProjTemp.GetMinMax(&rMin, &rMax);
    nProjections++;
    if(!(nProjections % 50)) {
      sString += _T(".");
      if(pMyParent != NULL)
        pMyParent->SendMessage(MSG_STATUS_MESSAGE, 0, (LPARAM)&sString);
    }
    if(rMin < fMin)fMin = rMin;
    if(rMax > fMax)fMax = rMax;
  }
  FindClose(hSearch);
  if(nProjections == 0){
    AfxMessageBox(_T("No Slice Files Found"), MB_ICONSTOP);
    return false;
  }
  volume_size_z = nProjections;

  double dVolReducion = (volume_size_x*volume_size_y*volume_size_z)/1024.0;
  dVolReducion /= cur_avail_graphic_mem_kb;
  dataset.resize(volume_size_x*volume_size_y*volume_size_z);

  // Let's read the projections in Memory
  hSearch = FindFirstFile(sPathName, &FileData);
  int i = 0;
  for(int z=0; z<volume_size_z; z++){
    sFileDati = FileData.cFileName;
    sString.Format(_T("Reading File: %s"), sFileDati);
    if(pMyParent != NULL)
      pMyParent->SendMessage(MSG_STATUS_MESSAGE, 0, (LPARAM)&sString);
    ProjTemp.ReadFromFitsFile(sDirectory+_T("\\")+sFileDati);
    float* pData = ProjTemp.pData;
    for(int x=0; x<volume_size_x; x++){
      for(int y=0; y<volume_size_y; y++){
        dataset[i++] = (GLubyte)(255.0*(*pData-fMin)/(fMax-fMin));
        pData++;
      }
    }
    FindNextFile(hSearch, &FileData);
  }
  FindClose(hSearch);

  return true;
}


bool
CVolumeWnd::Init(){
  if(!CheckGLErrors(_T("Entering: CVolumeWnd::Init()"))) return false;
  // --- upload volume ------------------------------------------------------
  GLint alignment;
  glGetIntegerv(GL_UNPACK_ALIGNMENT, &alignment);
  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
  glGenTextures(1, &volume_tex);
  glBindTexture(GL_TEXTURE_3D, volume_tex);
  glTexImage3D(GL_TEXTURE_3D, 0, GL_ALPHA, volume_size_x, volume_size_y, volume_size_z, 0, GL_ALPHA, GL_UNSIGNED_BYTE, &dataset[0]);
  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP);
  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP);
  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP);
  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
  glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
  glBindTexture(GL_TEXTURE_3D, 0);
  glPixelStorei(GL_UNPACK_ALIGNMENT, alignment);
  if(!CheckGLErrors(_T("CVolumeWnd::Init() - Volume Loading"))) return false;
  // --- create HistoPyramid -------------------------------------------------
  hpmc_c = HPMCcreateConstants();
  hpmc_h = HPMCcreateHistoPyramid(hpmc_c);
  HPMCsetLatticeSize(hpmc_h, volume_size_x, volume_size_y, volume_size_z);
  HPMCsetGridSize(hpmc_h, volume_size_x-1, volume_size_y-1, volume_size_z-1);
  float max_size = max(volume_size_x, max(volume_size_y, volume_size_z));
  HPMCsetGridExtent(hpmc_h, volume_size_x/max_size, volume_size_y/max_size, volume_size_z/max_size);
  HPMCsetFieldTexture3D(hpmc_h, volume_tex, GL_FALSE);
  // --- create traversal vertex shader --------------------------------------
  hpmc_th_shaded = HPMCcreateTraversalHandle(hpmc_h);
  if(hpmc_th_shaded == NULL) {
    CString sErrorMessage = _T("Volume too big !\r\n Try reducing the Volume Size and Retry");
    AfxMessageBox(sErrorMessage, MB_ICONSTOP);
    HPMCdestroyConstants(hpmc_c);
    //???????????????????????????HPMCdestroyHandle(hpmc_h);
    glDeleteTextures(1, &volume_tex);
    CheckGLErrors(_T("Error Exiting CVolumeWnd::Init()"));
    return false;
  }
  char *traversal_code = HPMCgetTraversalShaderFunctions(hpmc_th_shaded);
  const char* shaded_vsrc[2] = {
    traversal_code,
    shaded_vertex_shader.c_str()
  };
  shaded_v = glCreateShader(GL_VERTEX_SHADER);
  glShaderSource(shaded_v, 2, &shaded_vsrc[0], NULL);
  compileShader(shaded_v, "shaded vertex shader");
  free(traversal_code);
  const char* shaded_fsrc[1] = {
    shaded_fragment_shader.c_str()
  };
  shaded_f = glCreateShader(GL_FRAGMENT_SHADER);
  glShaderSource(shaded_f, 1, &shaded_fsrc[0], NULL);
  compileShader(shaded_f, "shaded fragment shader");
  // link program
  shaded_p = glCreateProgram();
  glAttachShader(shaded_p, shaded_v);
  glAttachShader(shaded_p, shaded_f);
  linkProgram(shaded_p, "shaded program");
  // associate program with traversal handle
  HPMCsetTraversalHandleProgram(hpmc_th_shaded, shaded_p, 0, 1, 2);
  // Set Light sources directions
  light1Param = glGetUniformLocation(shaded_p, "l1");
  light2Param = glGetUniformLocation(shaded_p, "l2");
  glUseProgram(shaded_p);
  glUniform4f(light1Param, 1.0f, 1.0f, 1.0f, 1.0f);
  glUniform4f(light2Param,  0.0f, 0.0f, 1.0f, 1.0f);
  glUseProgram(0);

  glPolygonOffset(1.0, 1.0);
  GLint cur_avail_graphic_mem_kb = 0;
  glGetIntegerv(GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX, &cur_avail_graphic_mem_kb);

  return CheckGLErrors(_T("Exiting CVolumeWnd::Init()"));
}


void
CVolumeWnd::ResizeOpenGLWindow(int w, int h) {
  if(w > h) {
    aspect_x = (double)w/(double)h;
    aspect_y = 1.0;
  } else {
    aspect_x = 1.0;
    aspect_y = (double)h/(double)w;
  }
  if(w > 0 && h > 0) {
    glViewport(0, 0, (GLsizei)w, (GLsizei)h);
  }
  RedrawOpenGLWindow();
}


void 
CVolumeWnd::OnRender() {
  // --- clear screen with the background color ------------------------
  glClearColor( 0.1f, 0.1f, 0.2f, 0.0f );

  glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );
  // Determine the aspect ratio
  GLdouble aspectratio = GLdouble(aspect_x) / GLdouble(aspect_y);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  // Set the camera parameters
  gluPerspective(m_camera.FieldOfView(), // Vertical field of view in degrees.
                 aspectratio,            // The aspect ratio.
                 0.5,                    // Near clipping
                 20.);                   // Far clipping
  // and the camera location
  m_camera.gluLookAt();

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();

  if(bShowFrame) {
    //draw the box framing everything
    glColor3f(0.0f,    0.0f,  0.7f);
    glBegin(GL_LINES);
      glVertex3f( 0.5f,   0.5f,  0.5f);
      glVertex3f( 0.5f,   0.5f, -0.5f);
      glVertex3f( 0.5f,  -0.5f,  0.5f);
      glVertex3f( 0.5f,  -0.5f, -0.5f);
      glVertex3f(-0.5f,   0.5f,  0.5f);
      glVertex3f(-0.5f,   0.5f, -0.5f);
      glVertex3f(-0.5f,  -0.5f,  0.5f);
      glVertex3f(-0.5f,  -0.5f, -0.5f);
      glVertex3f( 0.5f,   0.5f,  0.5f);
      glVertex3f( 0.5f,  -0.5f,  0.5f);
      glVertex3f( 0.5f,   0.5f, -0.5f);
      glVertex3f( 0.5f,  -0.5f, -0.5f);
      glVertex3f(-0.5f,   0.5f,  0.5f);
      glVertex3f(-0.5f,  -0.5f,  0.5f);
      glVertex3f(-0.5f,   0.5f, -0.5f);
      glVertex3f(-0.5f,  -0.5f, -0.5f);
      glVertex3f( 0.5f,   0.5f,  0.5f);
      glVertex3f(-0.5f,   0.5f,  0.5f);
      glVertex3f( 0.5f,   0.5f, -0.5f);
      glVertex3f(-0.5f,   0.5f, -0.5f);
      glVertex3f( 0.5f,  -0.5f,  0.5f);
      glVertex3f(-0.5f,  -0.5f,  0.5f);
      glVertex3f( 0.5f,  -0.5f, -0.5f);
      glVertex3f(-0.5f,  -0.5f, -0.5f);
    glEnd();
  }

  float max_size = max(volume_size_x, max(volume_size_y, volume_size_z));
  glTranslatef(-0.5f*volume_size_x/max_size,
               -0.5f*volume_size_y/max_size,
               -0.5f*volume_size_z/max_size);
  // --- build HistoPyramid --------------------------------------------------
  HPMCbuildHistopyramid(hpmc_h, iso);

  glTranslatef(dx, dy, dz);

  // --- render surface ------------------------------------------------------
  glEnable(GL_DEPTH_TEST);
  glColor3f(red, green, blue);// Surface Color
  HPMCextractVertices(hpmc_th_shaded);

  glUseProgram(0);
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  glDisable(GL_DEPTH_TEST);

  CString sString;
  sString.Format(_T("iso = %.3f"), iso);
  glRasterPos2f(-0.99, 0.95);
  for(int i=0; i<sString.GetLength(); i++) {
    glutBitmapCharacter(GLUT_BITMAP_8_BY_13, (int)sString.GetAt(i));
  }
}


BOOL 
CVolumeWnd::OnMouseWheel(UINT nFlags, short zDelta, CPoint pt) {
  iso += float(zDelta)/120.0*0.001;
  if(iso > 1.0) iso = 1.0;
  if(iso < 0.0) iso = 0.0;
  RedrawOpenGLWindow();
  return true;
}


void
CVolumeWnd::OnRButtonDown(UINT nFlags, CPoint point) {
  origin = point;
//enum eMouseMode {PANTILT, ROLLMOVE, PITCHYAW, DOLLYXY};
  m_camera.MouseDown(point.x, point.y);
  m_camera.MouseMode(CGrCamera::ROLLMOVE);
}


void
CVolumeWnd::OnRButtonUp(UINT nFlags, CPoint point) {
//enum eMouseMode {PANTILT, ROLLMOVE, PITCHYAW, DOLLYXY};
  m_camera.MouseMode(CGrCamera::PITCHYAW);
}


void
CVolumeWnd::OnMouseMove(UINT nFlags, CPoint point) {
  if(nFlags & MK_CONTROL) {
    if(nFlags & MK_LBUTTON) {
      dx += 0.001*(point.x - origin.x);
      dy += 0.001*(origin.y - point.y);
      origin = point;
      RedrawOpenGLWindow();
    }
    if(nFlags & MK_RBUTTON) {
      dz += 0.001*(origin.y - point.y);
      origin = point;
      RedrawOpenGLWindow();
    }
    return;
  }
  if(nFlags & MK_LBUTTON) {
     m_camera.MouseMove(point.x, point.y);
     RedrawOpenGLWindow();
   } else if(nFlags & MK_RBUTTON) {
     m_camera.MouseMove(point.x, point.y);
     RedrawOpenGLWindow();
  } 
}


void
CVolumeWnd::OnLButtonDown(UINT nFlags, CPoint point) {
  origin = point;
//enum eMouseMode {PANTILT, ROLLMOVE, PITCHYAW, DOLLYXY};
  m_camera.MouseDown(point.x, point.y);
}


void
CVolumeWnd::OnLButtonUp(UINT nFlags, CPoint point) {
//enum eMouseMode {PANTILT, ROLLMOVE, PITCHYAW, DOLLYXY};
  m_camera.MouseMode(CGrCamera::PITCHYAW);
}


void
CVolumeWnd::SetIso(float newIso) {
  if(newIso > 1.0f) newIso = 1.0f;
  if(newIso < 0.0f) newIso = 0.0f;
  iso = newIso;
  RedrawOpenGLWindow();
}


float
CVolumeWnd::GetIso() {
  return iso;
}


void
CVolumeWnd::SetRed(float newRed) {
  if(newRed > 1.0f) newRed = 1.0f;
  if(newRed < 0.0f) newRed = 0.0f;
  red = newRed;
  RedrawOpenGLWindow();
}


float
CVolumeWnd::GetRed() {
  return red;
}


void
CVolumeWnd::SetGreen(float newGreen) {
  if(newGreen > 1.0f) newGreen = 1.0f;
  if(newGreen < 0.0f) newGreen = 0.0f;
  green = newGreen;
  RedrawOpenGLWindow();
}


float
CVolumeWnd::GetGreen() {
  return green;
}


void
CVolumeWnd::SetBlue(float newBlue) {
  if(newBlue > 1.0f) newBlue = 1.0f;
  if(newBlue < 0.0f) newBlue = 0.0f;
  blue = newBlue;
  RedrawOpenGLWindow();
}


float
CVolumeWnd::GetBlue() {
  return blue;
}
